<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - STL</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <link type="text/css" rel="stylesheet" href="CSS/canvasStyles.css"/>

	</head>
	<body>
        <input type="range" min="0" max="1000" value="1000" id="crossSectionSlider">
        <button onclick="cameraControls.rotate(  45 * THREE.MathUtils.DEG2RAD, 0, true )">rotate theta 45deg</button>
        
        <div id="canvasContainer">  <!--Warning, things inside this div are generated and updated by JS, things may get strange-->
            <canvas id="canvas"></canvas>
        </div>
		<script type="module">

            import * as THREE from '/node_modules/three/build/three.module.js';
            import {STLLoader} from '/node_modules/three/examples/jsm/loaders/STLLoader.js'
            import { CSS2DRenderer, CSS2DObject } from '/node_modules/three/examples/jsm/renderers/CSS2DRenderer.js';
            import CameraControls from '/node_modules/camera-controls/dist/camera-controls.module.js'
            
            
            
            CameraControls.install( { THREE: THREE } );
            let clock = new THREE.Clock();
            
            
            let camera, scene, renderer, labelRenderer, cameraControls, plane;
            let frontFaceStencilMat, backFaceStencilMat, planeStencilMat;
            let planeMesh;

			init();
			render();

			function init() {
                
                let canvasContainer = document.getElementById("canvasContainer"); // get label container div
				let renderCanvas = document.getElementById("canvas"); // get canvas div
                THREE.Object3D.DefaultUp.set(0, 0, 1);
                
                // camera
                
                camera = new THREE.PerspectiveCamera(70, canvasContainer.clientWidth/canvasContainer.clientHeight);
                camera.position.set( 0, 0, 0 );
                
                // renderer
                
                renderer = new THREE.WebGLRenderer({ canvas: renderCanvas, antialias: true, alpha: false } );
                renderer.localClippingEnabled = true;
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( canvasContainer.clientWidth, canvasContainer.clientHeight );

                // label renderer
                
				labelRenderer = new CSS2DRenderer();
				labelRenderer.setSize( canvasContainer.clientWidth, canvasContainer.clientHeight );
				canvasContainer.appendChild( labelRenderer.domElement );
                
                
                //scene
                
                scene = new THREE.Scene();
                
                let light = new THREE.HemisphereLight(0xffffff, 1,1,100);
                scene.add(light);
                let Ambient = new THREE.AmbientLight( 0xffffff, 0.15 ); // soft white light
                scene.add( Ambient );
                
                                
                //controls
				
                cameraControls = new CameraControls( camera, renderer.domElement );
                
                
                
                //load mesh into scene
                
                function loadMesh(geometry) {
                    
                    geometry.computeBoundingBox();                    
                    let planeNormal = new THREE.Vector3(0, 0,-1).normalize(); //clipping planes
                    console.log(planeNormal)
                    plane = new THREE.Plane(planeNormal, geometry.boundingBox.max.z/2 + 0.1);
                    
                    let material = new THREE.MeshPhongMaterial({ 
                        color: 0x404A4C, 
                        specular: 0x050505, 
                        shininess: 50 ,
                        clippingPlanes: [plane], //TODO move this into the crossSection function
                        clipShadows: true,
                        side: THREE.DoubleSide,
                        polygonOffset: true,
                        polygonOffsetFactor: 1,
                        polygonOffsetUnits: 1
                    });
					let mesh = new THREE.Mesh( geometry, material );
					scene.add( mesh );
                    
                    let middle = new THREE.Vector3();
                    geometry.boundingBox.getCenter(middle);
                    mesh.geometry.applyMatrix4(new THREE.Matrix4().makeTranslation(-middle.x, -middle.y, -middle.z ) );
                    

                    console.log(mesh)
                    return mesh;

                }
                
                // grid and outline
                
                function helpers(geometry, mesh) {
                    let largestDimension = Math.max(geometry.boundingBox.max.x, 
                    geometry.boundingBox.max.y, 
                    geometry.boundingBox.max.z) // calculate the largest dimensions
    
                    
                    let factor =1 / Math.pow(10, Math.round(largestDimension).toString().length - 1); // calculate how much smaller we need to scale the object (e.g: 20cm cube needs to be scaled down by 10 (* 0.1))
                    largestDimension = largestDimension * factor; // update largestDimension to reflect new scale
                    geometry.scale(factor, factor, factor); //scale the geometry
                    
                    let sizeRoundedToUnit = Math.ceil(largestDimension *2) + Math.ceil(largestDimension * 1.1) ; //size of largest axis + 10%x2 rounded up to 1 units
                    
                    camera.far = sizeRoundedToUnit * 5; // set the camera far clip plane
                    camera.updateProjectionMatrix(); // updates the camera stuff so it works
                    cameraControls.maxDistance = sizeRoundedToUnit * 4; // sets the max distance the user can move the camera out
                    cameraControls.fitToSphere(mesh, false);
                    
                    
                    let edges = new THREE.EdgesGeometry(geometry, 75);
                    let line = new THREE.LineSegments( edges, new THREE.LineBasicMaterial( { color: 0xdedede, clippingPlanes: [plane] } ) );
                    scene.add( line ); // edge highlighting

                    let gridXZ = new THREE.GridHelper(sizeRoundedToUnit, sizeRoundedToUnit, 0xdedede, 0xffffff);
                    gridXZ.rotation.x = Math.PI/2;
                    gridXZ.position.set(0,0,-geometry.boundingBox.max.z - 0.001);
                    scene.add(gridXZ); //gridhelper plane
                    
                    

                    

                }
                
                
                function crossSection(geometry, mesh) {
                    
                    let planes = [ plane ];                    
                        // Set up the stencil materials
                    initStencilMaterials();

                    // Clip the cylinder stencil materials
                    frontFaceStencilMat.clippingPlanes = planes;
                    backFaceStencilMat.clippingPlanes = planes;

                        // Add the front face stencil
                    let frontMesh = new THREE.Mesh(geometry, frontFaceStencilMat);
                    frontMesh.rotation.copy(mesh.rotation);
                    scene.add(frontMesh);

                    // Add the back face stencil
                    let backMesh = new THREE.Mesh(geometry, backFaceStencilMat);
                    backMesh.rotation.copy(mesh.rotation);
                    scene.add(backMesh);

                    // Add the plane
                    let planeGeom = new THREE.PlaneGeometry(geometry.boundingBox.max.x*2,geometry.boundingBox.max.y*2);
                    planeMesh = new THREE.Mesh(planeGeom, planeStencilMat);
                    planeMesh.renderOrder = 1;
                    planeMesh.visible = false;
                    scene.add(planeMesh);
                    
                    crossSectionSlider.addEventListener('input', (event) => {
                        
                        let value = parseFloat(event.target.value);
                        
                        let factor = 1000 / (geometry.boundingBox.max.z * 2) //calculate how many times bigger 100 is than the size
                        let currentZ = (value / factor) - geometry.boundingBox.max.z; //divide by that factor, to scale, then shift down by half of the size, because the midpoint is 0 
                        plane.constant = currentZ;
                        planeMesh.position.set(0,0,currentZ);
                        
                        if (value == 1000 ) {
                            planeMesh.visible = false;
                            plane.constant = currentZ + 1;
                        } else if (value == 0) {
                            planeMesh.visible = true;
                            plane.constant = currentZ + 0.01;
                            planeMesh.position.set(0,0,currentZ + 0.01);
                            
                        } else { 
                            planeMesh.visible = true;
                        }
                        
                        renderer.render( scene, camera );
 
                    });  
                }
                
                

                
				// STL Loader

				let loader = new STLLoader();
                let meshFile = prompt("enter filename:", "Erin.stl")
				loader.load( meshFile, function (geometry) {    
                    let mesh = loadMesh(geometry);
                    helpers(geometry, mesh);
                    crossSection(geometry, mesh);
				} );

			}

            function initStencilMaterials() {
                    // PASS 1
                // everywhere that the back faces are visible (clipped region) the stencil
                // buffer is incremented by 1.
                backFaceStencilMat = new THREE.MeshBasicMaterial();
                backFaceStencilMat.depthWrite = false;
                backFaceStencilMat.depthTest = false;
                backFaceStencilMat.colorWrite = false;
                backFaceStencilMat.stencilWrite = true;
                backFaceStencilMat.stencilFunc = THREE.AlwaysStencilFunc;
                backFaceStencilMat.side = THREE.BackSide;
                backFaceStencilMat.stencilFail = THREE.IncrementWrapStencilOp;
                backFaceStencilMat.stencilZFail = THREE.IncrementWrapStencilOp;
                backFaceStencilMat.stencilZPass = THREE.IncrementWrapStencilOp;

                    // PASS 2
                // everywhere that the front faces are visible the stencil
                // buffer is decremented back to 0.
                frontFaceStencilMat = new THREE.MeshBasicMaterial();
                frontFaceStencilMat.depthWrite = false;
                frontFaceStencilMat.depthTest = false;
                frontFaceStencilMat.colorWrite = false;
                frontFaceStencilMat.stencilWrite = true;
                frontFaceStencilMat.stencilFunc = THREE.AlwaysStencilFunc;
                frontFaceStencilMat.side = THREE.FrontSide;
                frontFaceStencilMat.stencilFail = THREE.DecrementWrapStencilOp;
                frontFaceStencilMat.stencilZFail = THREE.DecrementWrapStencilOp;
                frontFaceStencilMat.stencilZPass = THREE.DecrementWrapStencilOp;

                    // PASS 3
                // draw the plane everywhere that the stencil buffer != 0, which will
                // only be in the clipped region where back faces are visible.
                planeStencilMat = new THREE.MeshPhongMaterial({ 
                        color: 0xF2A62C, 
                        shininess: 0 ,
                    });
                planeStencilMat.stencilWrite = true;
                planeStencilMat.stencilRef = 0;
                planeStencilMat.stencilFunc = THREE.NotEqualStencilFunc;
                planeStencilMat.stencilFail = THREE.ReplaceStencilOp;
                planeStencilMat.stencilZFail = THREE.ReplaceStencilOp;
                planeStencilMat.stencilZPass = THREE.ReplaceStencilOp;
            }

            function makeLabel(position, text, className = "label") { //default to using the label class, but can be changed if passed in
                    let labelDiv = document.createElement( 'div' );
                    labelDiv.className = className;
                    labelDiv.textContent = text;
                    let textLabel = new CSS2DObject( labelDiv );
                    textLabel.position.set(position.x,position.y,position.z); //set the rendered position to the passed in value
                    scene.add(textLabel);
                    return textLabel;
  
            }
            
			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function render() {
                
                
                let delta = clock.getDelta();
                let haveControlsUpdated = cameraControls.update( delta );
                
                requestAnimationFrame(render);
                
                if (haveControlsUpdated) {
                    renderer.render( scene, camera );
                    labelRenderer.render( scene, camera );
                }

			}



		</script>
	</body>
</html>