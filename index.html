<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - STL</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <link type="text/css" rel="stylesheet" href="CSS/canvasStyles.css"/>

	</head>
	<body>
        <input type="file" id="3DModelUpload"/>
        
        <div id="canvasContainer">  <!--Warning, things inside this div are generated and updated by JS, things may get strange-->
            <div id="loaderContainer"><div class="loader"></div></div>
            <div id="UIContainer">
                <input id="crossSectionSlider" orient="vertical" type="range" min="0" max="1000" value="1000" id="crossSectionSlider">
                <button id="zoomIn">+</button>
                <button id="zoomOut">-</button>
                <button id="homeView">home</button>
                <input id="wireFrameView" type="checkbox">
                <label for="wireFrameView">wireframe</label>
            </div>
            <canvas id="canvas"></canvas>
            <div id="labelContainer"></div>
        </div>
		<script type="module">
            import * as THREE from '/node_modules/three/build/three.module.js';
            import {STLLoader} from '/node_modules/three/examples/jsm/loaders/STLLoader.js'
            import { CSS2DRenderer, CSS2DObject } from '/node_modules/three/examples/jsm/renderers/CSS2DRenderer.js';
            import CameraControls from '/node_modules/camera-controls/dist/camera-controls.module.js'
            
            let modelFile
            document.getElementById ("3DModelUpload").addEventListener ("change", function () {
                let loaderDiv = document.getElementById("loaderContainer"); // re-add the loader div
                loaderDiv.style.opacity = "100";
                loaderDiv.style.pointerEvents = "auto";
                let reader = new FileReader();
                reader.readAsDataURL(this.files[0]);
                
                reader.addEventListener("load", function () {
                    modelFile = reader.result;
                    viewer();
                }, false);

            });
            
            
            function viewer() {
                
                let manager = new THREE.LoadingManager(); // create loadingmanager
                CameraControls.install( { THREE: THREE } ); // bind custom camera-controls library
                let clock = new THREE.Clock();

                let camera, cameraHome, scene, renderer, labelRenderer, cameraControls, plane;
                let frontFaceStencilMat, backFaceStencilMat, planeStencilMat;
                let scaleLabel, gridHelperSize;
                
                init();
                render();

                function init() {
                    let canvasContainer = document.getElementById("canvasContainer"); // get label container div
                    let renderCanvas = document.getElementById("canvas"); // get canvas div
                    THREE.Object3D.DefaultUp.set(0, 0, 1);

                    // camera

                    camera = new THREE.PerspectiveCamera(70, canvasContainer.clientWidth/canvasContainer.clientHeight);
                    camera.position.set( -10, -10, 10 ); //set camera position to 50 to transition in when the boundingbox is computer in helpers()

                    // renderer

                    renderer = new THREE.WebGLRenderer({ canvas: renderCanvas, antialias: true, alpha: false } );
                    renderer.localClippingEnabled = true;
                    renderer.setPixelRatio( window.devicePixelRatio );
                    renderer.setSize( canvasContainer.clientWidth, canvasContainer.clientHeight );

                    // label renderer

                    labelRenderer = new CSS2DRenderer();
                    labelRenderer.setSize( canvasContainer.clientWidth, canvasContainer.clientHeight );
                    document.getElementById("labelContainer").innerHTML = ''; //clear previous instance
                    labelContainer.appendChild( labelRenderer.domElement );


                    //scene
                    
                    scene = new THREE.Scene();
                    while(scene.children.length > 0){  // remove previous scene if it exists
                        scene.remove(scene.children[0]); 
                    }
                    scene.add(camera);
                    

                    let hemisphere = new THREE.HemisphereLight(0xffffff, 1,1,100);
                    scene.add(hemisphere);
                    let ambient = new THREE.AmbientLight( 0xffffff, 0.2 ); // soft white light
                    scene.add( ambient );
                    let point = new THREE.PointLight( 0xffffff, 0.5 );
                    point.position.set(0,0,0);
                    camera.add(point); // add point light to the camera


                    //controls

                    cameraControls = new CameraControls( camera, renderer.domElement );



                    //load mesh into scene

                    function loadMesh(geometry) {

                        geometry.computeBoundingBox();                    
                        let planeNormal = new THREE.Vector3(0, 0,-1).normalize(); //clipping planes
                        plane = new THREE.Plane(planeNormal, geometry.boundingBox.max.z/2 + 0.1);

                        let material = new THREE.MeshPhongMaterial({ 
                            color: 0x404A4C, 
                            specular: 0x050505, 
                            shininess: 50 ,
                            clippingPlanes: [plane], //TODO move this into the crossSection function
                            clipShadows: true,
                            side: THREE.DoubleSide,
                            polygonOffset: true,
                            polygonOffsetFactor: 1,
                            polygonOffsetUnits: 1
                        });
                        let mesh = new THREE.Mesh( geometry, material );
                        scene.add( mesh );

                        let middle = new THREE.Vector3();
                        geometry.boundingBox.getCenter(middle);
                        mesh.geometry.applyMatrix4(new THREE.Matrix4().makeTranslation(-middle.x, -middle.y, -middle.z ) );

                        return mesh;

                    }

                    // grid and outline

                    function helpers(geometry, mesh) {
                        let largestDimension = Math.max(geometry.boundingBox.max.x, 
                        geometry.boundingBox.max.y, 
                        geometry.boundingBox.max.z) // calculate the largest dimensions


                        let scaleFactor =1 / Math.pow(10, Math.round(largestDimension*2).toString().length - 1); // calculate how much smaller we need to scale the object (e.g: 20cm cube needs to be scaled down by 10 (* 0.1))
                        
                        let oneUnit = Math.pow(10, Math.round(largestDimension*2).toString().length - 1); // calculate the size of one unit before scaling down for display
                                    
                        largestDimension = largestDimension * scaleFactor; // update largestDimension to reflect new scale
                        geometry.scale(scaleFactor, scaleFactor, scaleFactor); //scale the geometry
                        
                        gridHelperSize = Math.ceil(largestDimension *2) + Math.ceil(largestDimension * 1.1) ; //size of largest axis + 10%x2 rounded up to 1 units

                        camera.far = gridHelperSize * 5; // set the camera far clip plane
                        camera.updateProjectionMatrix(); // updates the camera stuff so it works
                        cameraControls.maxDistance = gridHelperSize * 4; // sets the max distance the user can move the camera out
                        cameraControls.minDistance = 0.1; // set min distance so the scroll doesnt get "trapped" close
                        cameraHome = new THREE.Vector3(-gridHelperSize, -gridHelperSize*1.1, gridHelperSize/2.5) //set the home point of the camera to global
                        cameraControls.setLookAt(cameraHome.x, cameraHome.y, cameraHome.z, 0, 0, 0, false); // set camera position with slight offset and no transition so it slides into place
                        cameraControls.dolly(2, false);
                        cameraControls.addEventListener("update", onFirstRenderChanges);


                        let edges = new THREE.EdgesGeometry(geometry, 75);
                        let line = new THREE.LineSegments( edges, new THREE.LineBasicMaterial( { color: 0xdedede, clippingPlanes: [plane] } ) );
                        scene.add( line ); // edge highlighting

                        let gridXZ = new THREE.GridHelper(gridHelperSize, gridHelperSize, 0xdedede, 0xffffff);
                        gridXZ.rotation.x = Math.PI/2;
                        gridXZ.position.set(0,0,-geometry.boundingBox.max.z - 0.001);
                        scene.add(gridXZ); //gridhelper plane

                        // making the scale label
                        
                        
                        scaleLabel = makeLabel("scale",new THREE.Vector3(gridHelperSize/2 + 0.25,-gridHelperSize/2 + 0.5,-geometry.boundingBox.max.z), oneUnit + "mm")
                        
                    }


                    function crossSection(geometry, mesh) {
                        
                        document.getElementById("crossSectionSlider").value = "1000";
                        
                        let planes = [ plane ];                    
                            // Set up the stencil materials
                        initStencilMaterials();

                        // Clip the cylinder stencil materials
                        frontFaceStencilMat.clippingPlanes = planes;
                        backFaceStencilMat.clippingPlanes = planes;

                            // Add the front face stencil
                        let frontMesh = new THREE.Mesh(geometry, frontFaceStencilMat);
                        frontMesh.rotation.copy(mesh.rotation);
                        scene.add(frontMesh);

                        // Add the back face stencil
                        let backMesh = new THREE.Mesh(geometry, backFaceStencilMat);
                        backMesh.rotation.copy(mesh.rotation);
                        scene.add(backMesh);

                        // Add the plane
                        let planeGeom = new THREE.PlaneGeometry(geometry.boundingBox.max.x*2,geometry.boundingBox.max.y*2);
                        let planeMesh = new THREE.Mesh(planeGeom, planeStencilMat);
                        planeMesh.renderOrder = 1;
                        planeMesh.visible = false;
                        scene.add(planeMesh);

                        crossSectionSlider.addEventListener('input', (event) => {

                            let value = parseFloat(event.target.value);

                            let factor = 1000 / (geometry.boundingBox.max.z * 2) //calculate how many times bigger 100 is than the size
                            let currentZ = (value / factor) - geometry.boundingBox.max.z; //divide by that factor, to scale, then shift down by half of the size, because the midpoint is 0 
                            plane.constant = currentZ;
                            planeMesh.position.set(0,0,currentZ);

                            if (value == 1000 ) { // if the slider is all the way up, hide the colour plane and move the clipping plane up to be invisible
                                planeMesh.visible = false;
                                plane.constant = currentZ + 1;
                            } else if (value == 0) { // if the slider is all the way down, move both the colour plane and clip plane to the lowest safe positions
                                planeMesh.visible = true;
                                plane.constant = currentZ + 0.001;
                                planeMesh.position.set(0,0,currentZ + 0.01);

                            } else { 
                                planeMesh.visible = true; // set the colour plane to visible if anywhere inbetween max and min
                            }

                            renderer.render( scene, camera );

                        });  
                    }


                    function UIManager(geometry, mesh) { //handles all ui interaction, other than slider
                        let solidMaterial = mesh.material; // set the solid material to the one onload
                        let wireframeMaterial = new THREE.MeshLambertMaterial({ // set wireframe material
                            color: 0x404A4C, 
                            clippingPlanes: [plane], //TODO move this into the crossSection function
                            clipShadows: true,
                            side: THREE.DoubleSide,
                            polygonOffset: true,
                            polygonOffsetFactor: 1,
                            polygonOffsetUnits: 1,
                            wireframe: true
                        });
                        document.getElementById("zoomIn").addEventListener("click", function(){cameraControls.dolly(  1, true )});
                        document.getElementById("zoomOut").addEventListener("click", function(){cameraControls.dolly(  -1, true )}); 
                        document.getElementById("homeView").addEventListener("click", function(){cameraControls.setLookAt(cameraHome.x, cameraHome.y, cameraHome.z, 0, 0, 0, true);}); 
                        document.getElementById("wireFrameView").addEventListener("change", function(){
                            if (this.checked) {
                                mesh.material = wireframeMaterial;
                            } else {
                                mesh.material = solidMaterial;
                            }
                            renderer.render( scene, camera );
                        }); 
                    }

                    // STL Loader

                    let loader = new STLLoader(manager);

                    loader.load( modelFile, function (geometry) { 
                        let mesh = loadMesh(geometry);
                        helpers(geometry, mesh);
                        crossSection(geometry, mesh);
                        UIManager(geometry, mesh);
                    });

                    window.addEventListener( 'resize', onWindowResize );

                }

                function initStencilMaterials() {
                        // PASS 1
                    // everywhere that the back faces are visible (clipped region) the stencil
                    // buffer is incremented by 1.
                    backFaceStencilMat = new THREE.MeshBasicMaterial();
                    backFaceStencilMat.depthWrite = false;
                    backFaceStencilMat.depthTest = false;
                    backFaceStencilMat.colorWrite = false;
                    backFaceStencilMat.stencilWrite = true;
                    backFaceStencilMat.stencilFunc = THREE.AlwaysStencilFunc;
                    backFaceStencilMat.side = THREE.BackSide;
                    backFaceStencilMat.stencilFail = THREE.IncrementWrapStencilOp;
                    backFaceStencilMat.stencilZFail = THREE.IncrementWrapStencilOp;
                    backFaceStencilMat.stencilZPass = THREE.IncrementWrapStencilOp;

                        // PASS 2
                    // everywhere that the front faces are visible the stencil
                    // buffer is decremented back to 0.
                    frontFaceStencilMat = new THREE.MeshBasicMaterial();
                    frontFaceStencilMat.depthWrite = false;
                    frontFaceStencilMat.depthTest = false;
                    frontFaceStencilMat.colorWrite = false;
                    frontFaceStencilMat.stencilWrite = true;
                    frontFaceStencilMat.stencilFunc = THREE.AlwaysStencilFunc;
                    frontFaceStencilMat.side = THREE.FrontSide;
                    frontFaceStencilMat.stencilFail = THREE.DecrementWrapStencilOp;
                    frontFaceStencilMat.stencilZFail = THREE.DecrementWrapStencilOp;
                    frontFaceStencilMat.stencilZPass = THREE.DecrementWrapStencilOp;

                        // PASS 3
                    // draw the plane everywhere that the stencil buffer != 0, which will
                    // only be in the clipped region where back faces are visible.
                    planeStencilMat = new THREE.MeshPhongMaterial({ 
                            color: 0xF2A62C, 
                            shininess: 0 ,
                        });
                    planeStencilMat.stencilWrite = true;
                    planeStencilMat.stencilRef = 0;
                    planeStencilMat.stencilFunc = THREE.NotEqualStencilFunc;
                    planeStencilMat.stencilFail = THREE.ReplaceStencilOp;
                    planeStencilMat.stencilZFail = THREE.ReplaceStencilOp;
                    planeStencilMat.stencilZPass = THREE.ReplaceStencilOp;
                }

                function makeLabel(name, position, text, className = "label") { //default to using the label class, but can be changed if passed in
                        let labelDiv = document.createElement( 'div' );
                        labelDiv.className = className;
                        labelDiv.textContent = text;
                        let textLabel = new CSS2DObject( labelDiv );
                        textLabel.position.set(position.x,position.y,position.z); //set the rendered position to the passed in value
                        scene.add(textLabel);
                        return textLabel;

                }

                function onWindowResize() {

                    camera.aspect = canvasContainer.clientWidth / canvasContainer.clientHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize( canvasContainer.clientWidth, canvasContainer.clientHeight );
                    labelRenderer.setSize( canvasContainer.clientWidth, canvasContainer.clientHeight );
                    renderer.render( scene, camera );
                    labelRenderer.render( scene, camera );

                }

                function updateScaleGrid() {
                    let cameraFacing = camera.getWorldDirection(new THREE.Vector3(0, 0, 0));
                    let x = (cameraFacing.x);
                    let y = (cameraFacing.y);
                    let z = (cameraFacing.z);
                    
                    let newX, newY;
                    
                    if (Math.abs(x) > Math.abs(y)) { // determin which value of the cameras position vector is absolutely bigger
                        if (x > 0) {
                            newX = -gridHelperSize/2 - 0.25
                            newY = gridHelperSize/2 - 0.5 // set position of label to EAST
                        } else {
                            newX = gridHelperSize/2 + 0.25
                            newY = -gridHelperSize/2 + 0.5
                        } // set position of label to WEST
                    } else {
                        if (y > 0) {
                            newX = -gridHelperSize/2 + 0.5
                            newY = -gridHelperSize/2 -0.25 // set position of label to NORTH
                        } else {
                            newX = gridHelperSize/2 - 0.5
                            newY = gridHelperSize/2 + 0.25
                        } // set position of label to SOUTH 
                    };
                    
                    scaleLabel.position.set(newX, newY, scaleLabel.position.z);
                    
                }

                function onFirstRenderChanges () { // code to call once, when the first frame of the render happens
                    let loaderDiv = document.getElementById("loaderContainer"); // remove the loader div
                    loaderDiv.style.opacity = "0";
                    loaderDiv.style.pointerEvents = "none";
                    let cameraPosition = cameraControls.getPosition();//get cameras current position
                    cameraControls.dolly(-2, true); // transition into the final camera position
                    cameraControls.removeEventListener( "update", onFirstRenderChanges );
                }
                
                function render() {

                    let delta = clock.getDelta();
                    let haveControlsUpdated = cameraControls.update( delta );
                    requestAnimationFrame(render);

                    if (haveControlsUpdated) {
                        updateScaleGrid();
                        renderer.render( scene, camera );
                        labelRenderer.render( scene, camera );


                    }

                }
            };


		</script>
	</body>
</html>