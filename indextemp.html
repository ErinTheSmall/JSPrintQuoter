<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - STL</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

	</head>
	<body>
        <input type="range" min="0" max="100" value="100" id="slider">
        <button onclick="cameraControls.rotate(  45 * THREE.MathUtils.DEG2RAD, 0, true )">rotate theta 45deg</button>

        <div id="model" style="width: 2000px; height: 1000px; background-color: red;">3D Model viewer</div>

		<script type="module">

            import * as THREE from '/node_modules/three/build/three.module.js';
            import {STLLoader} from '/node_modules/three/examples/jsm/loaders/STLLoader.js'
            import CameraControls from '/node_modules/camera-controls/dist/camera-controls.module.js'
            
            
            CameraControls.install( { THREE: THREE } );
            const clock = new THREE.Clock();
            
            
            let camera, scene, renderer, cameraControls, plane;
            let frontFaceStencilMat, backFaceStencilMat, planeStencilMat;
            let planeMesh;

			init();
			render();

			function init() {
                
				let container = document.getElementById("model");  
                THREE.Object3D.DefaultUp.set(0, 0, 1);
                
                // camera
                
                camera = new THREE.PerspectiveCamera(70, container.clientWidth/container.clientHeight, 1, 1000);
                camera.position.set( 0, 0, 5 );
                
                // renderer

				renderer = new THREE.WebGLRenderer( { antialias: true, alpha: false } );
                renderer.localClippingEnabled = true;
				renderer.setSize(container.clientWidth, container.clientHeight);
				container.appendChild( renderer.domElement );
                
                //scene
                
                scene = new THREE.Scene();
                
                const light = new THREE.HemisphereLight(0xffffff, 1,1,100);
                scene.add(light);
                const Ambient = new THREE.AmbientLight( 0xffffff, 0.15 ); // soft white light
                scene.add( Ambient );
                
                                
                //controls
				
                cameraControls = new CameraControls( camera, renderer.domElement );


                //load mesh into scene
                
                function loadMesh(geometry) {
                    
                    geometry.computeBoundingBox();                    
                    let planeNormal = new THREE.Vector3(0, 0,-1).normalize(); //clipping planes
                    console.log(planeNormal)
                    plane = new THREE.Plane(planeNormal, geometry.boundingBox.max.z/2 + 0.1);
                    
                    let material = new THREE.MeshPhongMaterial({ 
                        color: 0x404A4C, 
                        specular: 0x050505, 
                        shininess: 50 ,
                        clippingPlanes: [plane], //TODO move this into the crossSection function
                        clipShadows: true,
                        side: THREE.DoubleSide,
                        polygonOffset: true,
                        polygonOffsetFactor: 1,
                        polygonOffsetUnits: 1
                    });
					let mesh = new THREE.Mesh( geometry, material );
					scene.add( mesh );
                    
                    let middle = new THREE.Vector3();
                    geometry.boundingBox.getCenter(middle);
                    mesh.geometry.applyMatrix4(new THREE.Matrix4().makeTranslation(-middle.x, -middle.y, -middle.z ) );

                    cameraControls.fitToSphere(mesh, false);

                    console.log(mesh)
                    return mesh;

                }
                
                // grid and outline
                
                function helpers(geometry) {
                    var largestDimension = Math.max(geometry.boundingBox.max.x,
                    geometry.boundingBox.max.y, 
                    geometry.boundingBox.max.z)
                    var sizeRoundedToCM = Math.ceil(largestDimension *2 / 10) * 10 + 2 * Math.ceil(0.2 * largestDimension * 2 / 10) * 10; //size of largest axis + 10%x2 

                    const edges = new THREE.EdgesGeometry(geometry, 75);
                    const line = new THREE.LineSegments( edges, new THREE.LineBasicMaterial( { color: 0xdedede, clippingPlanes: [plane] } ) );
                    scene.add( line ); // edge highlighting

                    var gridXZ = new THREE.GridHelper(sizeRoundedToCM, sizeRoundedToCM / 10 , 0xdedede, 0xffffff);
                    gridXZ.rotation.x = Math.PI/2;
                    gridXZ.position.set(0,0,-geometry.boundingBox.max.z);
                    scene.add(gridXZ); //gridhelper plane

                }
                
                
                function crossSection(geometry, mesh) {
                    
                    var planes = [ plane ];                    
                        // Set up the stencil materials
                    initStencilMaterials();

                    // Clip the cylinder stencil materials
                    frontFaceStencilMat.clippingPlanes = planes;
                    backFaceStencilMat.clippingPlanes = planes;

                        // Add the front face stencil
                    var frontMesh = new THREE.Mesh(geometry, frontFaceStencilMat);
                    frontMesh.rotation.copy(mesh.rotation);
                    scene.add(frontMesh);

                    // Add the back face stencil
                    var backMesh = new THREE.Mesh(geometry, backFaceStencilMat);
                    backMesh.rotation.copy(mesh.rotation);
                    scene.add(backMesh);

                    // Add the plane
                    var planeGeom = new THREE.PlaneGeometry(geometry.boundingBox.max.x*2,geometry.boundingBox.max.y*2);
                    planeMesh = new THREE.Mesh(planeGeom, planeStencilMat);
                    planeMesh.renderOrder = 1;
                    scene.add(planeMesh);
                    
                    
                    slider.addEventListener('input', (event) => {
                        
                        const value = parseFloat(event.target.value);
                        
                        var factor = 100 / (geometry.boundingBox.max.z * 2) //calculate how many times bigger 100 is than the size
                        let currentZ = (value / factor) - geometry.boundingBox.max.z + 0.1; //divide by that factor, to scale, then shift down by half of the size, because the midpoint is 0 
                        plane.constant = currentZ;
                        planeMesh.position.set(0,0,currentZ);
                        renderer.render( scene, camera );
 
                    });  
                }
                
                

                
				// STL Loader

				let loader = new STLLoader();
                let meshFile = prompt("enter filename:", "Erin.stl")
				loader.load( meshFile, function (geometry) {    
                    let mesh = loadMesh(geometry);
    
                    helpers(geometry);
                    crossSection(geometry, mesh);
                
				} );


			}

            function initStencilMaterials() {
                    // PASS 1
                // everywhere that the back faces are visible (clipped region) the stencil
                // buffer is incremented by 1.
                backFaceStencilMat = new THREE.MeshBasicMaterial();
                backFaceStencilMat.depthWrite = false;
                backFaceStencilMat.depthTest = false;
                backFaceStencilMat.colorWrite = false;
                backFaceStencilMat.stencilWrite = true;
                backFaceStencilMat.stencilFunc = THREE.AlwaysStencilFunc;
                backFaceStencilMat.side = THREE.BackSide;
                backFaceStencilMat.stencilFail = THREE.IncrementWrapStencilOp;
                backFaceStencilMat.stencilZFail = THREE.IncrementWrapStencilOp;
                backFaceStencilMat.stencilZPass = THREE.IncrementWrapStencilOp;

                    // PASS 2
                // everywhere that the front faces are visible the stencil
                // buffer is decremented back to 0.
                frontFaceStencilMat = new THREE.MeshBasicMaterial();
                frontFaceStencilMat.depthWrite = false;
                frontFaceStencilMat.depthTest = false;
                frontFaceStencilMat.colorWrite = false;
                frontFaceStencilMat.stencilWrite = true;
                frontFaceStencilMat.stencilFunc = THREE.AlwaysStencilFunc;
                frontFaceStencilMat.side = THREE.FrontSide;
                frontFaceStencilMat.stencilFail = THREE.DecrementWrapStencilOp;
                frontFaceStencilMat.stencilZFail = THREE.DecrementWrapStencilOp;
                frontFaceStencilMat.stencilZPass = THREE.DecrementWrapStencilOp;

                    // PASS 3
                // draw the plane everywhere that the stencil buffer != 0, which will
                // only be in the clipped region where back faces are visible.
                planeStencilMat = new THREE.MeshPhongMaterial({ 
                        color: 0xF2A62C, 
                        shininess: 0 ,
                    });
                planeStencilMat.stencilWrite = true;
                planeStencilMat.stencilRef = 0;
                planeStencilMat.stencilFunc = THREE.NotEqualStencilFunc;
                planeStencilMat.stencilFail = THREE.ReplaceStencilOp;
                planeStencilMat.stencilZFail = THREE.ReplaceStencilOp;
                planeStencilMat.stencilZPass = THREE.ReplaceStencilOp;
            }

            
			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function render() {
                
                const delta = clock.getDelta();
                const haveControlsUpdated = cameraControls.update( delta );
                
                requestAnimationFrame(render);
                
                if (haveControlsUpdated) {
                    renderer.render( scene, camera );
                }

			}



		</script>
	</body>
</html>