<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - STL</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

	</head>
	<body>
        <input type="range" min="0" max="1000" value="1000" id="slider">
        <button onclick="cameraControls.rotate(  45 * THREE.MathUtils.DEG2RAD, 0, true )">rotate theta 45deg</button>

        <div id="model" style="width: 2000px; height: 1000px; background-color: red;">3D Model viewer</div>

		<script type="module">

            import * as THREE from '/node_modules/three/build/three.module.js';
            import {STLLoader} from '/node_modules/three/examples/jsm/loaders/STLLoader.js'
            import CameraControls from '/node_modules/camera-controls/dist/camera-controls.module.js'
            
            
            CameraControls.install( { THREE: THREE } );
            let clock = new THREE.Clock();
            
            
            let camera, scene, renderer, cameraControls, plane;
            let frontFaceStencilMat, backFaceStencilMat, planeStencilMat;
            let planeMesh;

			init();
			render();

			function init() {
                
				let container = document.getElementById("model");  
                THREE.Object3D.DefaultUp.set(0, 0, 1);
                
                // camera
                
                camera = new THREE.PerspectiveCamera(70, container.clientWidth/container.clientHeight);
                
                // renderer

				renderer = new THREE.WebGLRenderer( { antialias: true, alpha: false } );
                renderer.localClippingEnabled = true;
				renderer.setSize(container.clientWidth, container.clientHeight);
				container.appendChild( renderer.domElement );
                
                //scene
                
                scene = new THREE.Scene();
                
                let light = new THREE.HemisphereLight(0xffffff, 1,1,100);
                scene.add(light);
                let Ambient = new THREE.AmbientLight( 0xffffff, 0.15 ); // soft white light
                scene.add( Ambient );
                
                                
                //controls
				
                cameraControls = new CameraControls( camera, renderer.domElement );
                


                //load mesh into scene
                
                function loadMesh(geometry) {
                    
                    geometry.computeBoundingBox();                    
                    let planeNormal = new THREE.Vector3(0, 0,-1).normalize(); //clipping planes
                    console.log(planeNormal)
                    plane = new THREE.Plane(planeNormal, geometry.boundingBox.max.z/2 + 0.1);
                    
                    let material = new THREE.MeshPhongMaterial({ 
                        color: 0x404A4C, 
                        specular: 0x050505, 
                        shininess: 50 ,
                        clippingPlanes: [plane], //TODO move this into the crossSection function
                        clipShadows: true,
                        side: THREE.DoubleSide,
                        polygonOffset: true,
                        polygonOffsetFactor: 1,
                        polygonOffsetUnits: 1
                    });
					let mesh = new THREE.Mesh( geometry, material );
					scene.add( mesh );
                    
                    let middle = new THREE.Vector3();
                    geometry.boundingBox.getCenter(middle);
                    mesh.geometry.applyMatrix4(new THREE.Matrix4().makeTranslation(-middle.x, -middle.y, -middle.z ) );

                    cameraControls.fitToSphere(mesh, false);

                    console.log(mesh)
                    return mesh;

                }
                
                // grid and outline
                
                function helpers(geometry, mesh) {
                    let largestDimension = Math.max(geometry.boundingBox.max.x, 
                    geometry.boundingBox.max.y, 
                    geometry.boundingBox.max.z) // calculate the largest dimensions
    
                    
                    let factor =1 / Math.pow(10, Math.round(largestDimension).toString().length - 1); // calculate how much smaller we need to scale the object (e.g: 20cm cube needs to be scaled down by 10 (* 0.1))
                    largestDimension = largestDimension * factor; // update largestDimension to reflect new scale
                    geometry.scale(factor, factor, factor); //scale the geometry
                    
                    camera.far = largestDimension *20; // set the camera far clip plane
                    camera.updateProjectionMatrix(); // updates the camera stuff so it works
                    
                    cameraControls.maxDistance = largestDimension * 15; // sets the max distance the user can move the camera out
                    
                    let sizeRoundedToUnit = Math.ceil(largestDimension *2) + Math.ceil(largestDimension * 1.1) ; //size of largest axis + 10%x2 
                    
                    
                    let edges = new THREE.EdgesGeometry(geometry, 75);
                    let line = new THREE.LineSegments( edges, new THREE.LineBasicMaterial( { color: 0xdedede, clippingPlanes: [plane] } ) );
                    scene.add( line ); // edge highlighting

                    let gridXZ = new THREE.GridHelper(sizeRoundedToUnit, sizeRoundedToUnit, 0xdedede, 0xffffff);
                    gridXZ.rotation.x = Math.PI/2;
                    gridXZ.position.set(0,0,-geometry.boundingBox.max.z - 0.001);
                    scene.add(gridXZ); //gridhelper plane

                }
                
                
                function crossSection(geometry, mesh) {
                    
                    let planes = [ plane ];                    
                        // Set up the stencil materials
                    initStencilMaterials();

                    // Clip the cylinder stencil materials
                    frontFaceStencilMat.clippingPlanes = planes;
                    backFaceStencilMat.clippingPlanes = planes;

                        // Add the front face stencil
                    let frontMesh = new THREE.Mesh(geometry, frontFaceStencilMat);
                    frontMesh.rotation.copy(mesh.rotation);
                    scene.add(frontMesh);

                    // Add the back face stencil
                    let backMesh = new THREE.Mesh(geometry, backFaceStencilMat);
                    backMesh.rotation.copy(mesh.rotation);
                    scene.add(backMesh);

                    // Add the plane
                    let planeGeom = new THREE.PlaneGeometry(geometry.boundingBox.max.x*2,geometry.boundingBox.max.y*2);
                    planeMesh = new THREE.Mesh(planeGeom, planeStencilMat);
                    planeMesh.renderOrder = 1;
                    planeMesh.visible = false;
                    scene.add(planeMesh);
                    
                    slider.addEventListener('input', (event) => {
                        
                        let value = parseFloat(event.target.value);
                        
                        let factor = 1000 / (geometry.boundingBox.max.z * 2) //calculate how many times bigger 100 is than the size
                        let currentZ = (value / factor) - geometry.boundingBox.max.z; //divide by that factor, to scale, then shift down by half of the size, because the midpoint is 0 
                        plane.constant = currentZ;
                        planeMesh.position.set(0,0,currentZ);
                        
                        if (value == 1000 ) {
                            planeMesh.visible = false;
                            plane.constant = currentZ + 1;
                        } else if (value == 0) {
                            planeMesh.visible = true;
                            plane.constant = currentZ + 0.01;
                            planeMesh.position.set(0,0,currentZ + 0.01);
                            
                        } else { 
                            planeMesh.visible = true;
                        }
                        
                        renderer.render( scene, camera );
 
                    });  
                }
                
                

                
				// STL Loader

				let loader = new STLLoader();
                let meshFile = prompt("enter filename:", "Erin.stl")
				loader.load( meshFile, function (geometry) {    
                    let mesh = loadMesh(geometry);
                    helpers(geometry, mesh);
                    crossSection(geometry, mesh);
				} );


			}

            function initStencilMaterials() {
                    // PASS 1
                // everywhere that the back faces are visible (clipped region) the stencil
                // buffer is incremented by 1.
                backFaceStencilMat = new THREE.MeshBasicMaterial();
                backFaceStencilMat.depthWrite = false;
                backFaceStencilMat.depthTest = false;
                backFaceStencilMat.colorWrite = false;
                backFaceStencilMat.stencilWrite = true;
                backFaceStencilMat.stencilFunc = THREE.AlwaysStencilFunc;
                backFaceStencilMat.side = THREE.BackSide;
                backFaceStencilMat.stencilFail = THREE.IncrementWrapStencilOp;
                backFaceStencilMat.stencilZFail = THREE.IncrementWrapStencilOp;
                backFaceStencilMat.stencilZPass = THREE.IncrementWrapStencilOp;

                    // PASS 2
                // everywhere that the front faces are visible the stencil
                // buffer is decremented back to 0.
                frontFaceStencilMat = new THREE.MeshBasicMaterial();
                frontFaceStencilMat.depthWrite = false;
                frontFaceStencilMat.depthTest = false;
                frontFaceStencilMat.colorWrite = false;
                frontFaceStencilMat.stencilWrite = true;
                frontFaceStencilMat.stencilFunc = THREE.AlwaysStencilFunc;
                frontFaceStencilMat.side = THREE.FrontSide;
                frontFaceStencilMat.stencilFail = THREE.DecrementWrapStencilOp;
                frontFaceStencilMat.stencilZFail = THREE.DecrementWrapStencilOp;
                frontFaceStencilMat.stencilZPass = THREE.DecrementWrapStencilOp;

                    // PASS 3
                // draw the plane everywhere that the stencil buffer != 0, which will
                // only be in the clipped region where back faces are visible.
                planeStencilMat = new THREE.MeshPhongMaterial({ 
                        color: 0xF2A62C, 
                        shininess: 0 ,
                    });
                planeStencilMat.stencilWrite = true;
                planeStencilMat.stencilRef = 0;
                planeStencilMat.stencilFunc = THREE.NotEqualStencilFunc;
                planeStencilMat.stencilFail = THREE.ReplaceStencilOp;
                planeStencilMat.stencilZFail = THREE.ReplaceStencilOp;
                planeStencilMat.stencilZPass = THREE.ReplaceStencilOp;
            }

            
			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function render() {
                
                let delta = clock.getDelta();
                let haveControlsUpdated = cameraControls.update( delta );
                
                requestAnimationFrame(render);
                
                if (haveControlsUpdated) {
                    renderer.render( scene, camera );
                }

			}



		</script>
	</body>
</html>